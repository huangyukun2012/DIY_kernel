!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ALT_L	include/keyboard.h	54;"	d
ALT_R	include/keyboard.h	55;"	d
ANY	include/proc.h	89;"	d
APPS	include/keyboard.h	47;"	d
ARDStruct	boot/loader.asm	/^ARDStruct		equ	BaseOfLoaderPhyAddr + _ARDStruct$/;"	d
ASM	Makefile	/^ASM		= nasm$/;"	m
ASMBFLAGS	Makefile	/^ASMBFLAGS	= -I boot\/include\/$/;"	m
ASMKFLAGS	Makefile	/^ASMKFLAGS	= -I include\/ -f elf$/;"	m
ASSERT	include/err.h	6;"	d
ATA_IDENTIFY	include/hd.h	263;"	d
ATA_READ	include/hd.h	264;"	d
ATA_WRITE	include/hd.h	265;"	d
AT_WINI_IRQ	include/const.h	84;"	d
BACKSPACE	include/keyboard.h	43;"	d
BLACK	include/const.h	29;"	d
BLUE	include/const.h	33;"	d
BOTH	include/msg.h	38;"	d
BRIGHT	include/const.h	35;"	d
BUF	include/msg.h	63;"	d
BaseOfStack	boot/boot.asm	/^BaseOfStack		equ	0100h	; 调试状态下堆栈基地址(栈底, 从这个位置向低地址生长)$/;"	d
BaseOfStack	boot/boot.asm	/^BaseOfStack		equ	07c00h	; Boot状态下堆栈基地址(栈底, 从这个位置向低地址生长)$/;"	d
BaseOfStack	boot/loader.asm	/^BaseOfStack	equ	0100h$/;"	d
BootMessage	boot/boot.asm	/^BootMessage:		db	"Booting  "; 9字节, 不够则用空格补齐. 序号 0$/;"	d
CAPS_LOCK	include/keyboard.h	58;"	d
CASCADE_IRQ	include/const.h	77;"	d
CC	Makefile	/^CC		= gcc$/;"	m
CFLAGS	Makefile	/^CFLAGS		= -m32 -I include\/ -c -fno-builtin$/;"	m
CLOCK_IRQ	include/const.h	75;"	d
CLOSE	include/msg.h	/^	   OPEN, CLOSE, READ, WRITE, LSEEK, STAT, UNLINK,   $/;"	e	enum:msgtype
CNT	include/msg.h	58;"	d
COLOR	kernel/console.c	7;"	d	file:
CONSOLE	include/console.h	/^}CONSOLE;$/;"	t	typeref:struct:s_console
CONSOLE_H	include/console.h	2;"	d
CRTC_ADDR_REG	include/const.h	88;"	d
CRTC_DATA_REG	include/const.h	89;"	d
CTRL_L	include/keyboard.h	52;"	d
CTRL_R	include/keyboard.h	53;"	d
CURSOR_END_REG	include/const.h	91;"	d
CURSOR_H	include/const.h	95;"	d
CURSOR_L	include/const.h	96;"	d
CURSOR_START_REG	include/const.h	90;"	d
DASM	Makefile	/^DASM		= ndisasm$/;"	m
DASMFLAGS	Makefile	/^DASMFLAGS	= -u -o $(ENTRYPOINT) -e $(ENTRYOFFSET)$/;"	m
DASMOUTPUT	Makefile	/^DASMOUTPUT	= kernel.bin.asm$/;"	m
DA_32	include/protect.h	91;"	d
DA_386CGate	include/protect.h	109;"	d
DA_386IGate	include/protect.h	110;"	d
DA_386TGate	include/protect.h	111;"	d
DA_386TSS	include/protect.h	108;"	d
DA_C	include/protect.h	101;"	d
DA_CCO	include/protect.h	103;"	d
DA_CCOR	include/protect.h	104;"	d
DA_CR	include/protect.h	102;"	d
DA_DPL0	include/protect.h	93;"	d
DA_DPL1	include/protect.h	94;"	d
DA_DPL2	include/protect.h	95;"	d
DA_DPL3	include/protect.h	96;"	d
DA_DR	include/protect.h	98;"	d
DA_DRW	include/protect.h	99;"	d
DA_DRWA	include/protect.h	100;"	d
DA_LDT	include/protect.h	106;"	d
DA_LIMIT_4K	include/protect.h	92;"	d
DA_TaskGate	include/protect.h	107;"	d
DEBUG_rw_sector	fs/opera.c	/^	int DEBUG_rw_sector = 0;$/;"	v
DEFAULT_CHAR_COLOR	include/console.h	11;"	d
DELETE	include/keyboard.h	80;"	d
DESCRIPTOR	include/protect.h	/^}DESCRIPTOR;$/;"	t	typeref:struct:descriptor
DEVICE	include/msg.h	61;"	d
DEV_CDROM	include/drive.h	7;"	d
DEV_CHAR_TTY	include/drive.h	9;"	d
DEV_CLOSE	include/msg.h	/^	DEV_CLOSE,$/;"	e	enum:msgtype
DEV_FLOPPY	include/drive.h	6;"	d
DEV_HD	include/drive.h	8;"	d
DEV_IOCTL	include/msg.h	/^	DEV_IOCTL$/;"	e	enum:msgtype
DEV_OPEN	include/msg.h	/^	DEV_OPEN=1001,$/;"	e	enum:msgtype
DEV_READ	include/msg.h	/^	DEV_READ,$/;"	e	enum:msgtype
DEV_SCSI	include/drive.h	10;"	d
DEV_WRITE	include/msg.h	/^	DEV_WRITE,$/;"	e	enum:msgtype
DIOCTL_GET_GEO	include/msg.h	72;"	d
DIR_ENTRY_SIZE	include/fs.h	73;"	d
DOWN	include/keyboard.h	86;"	d
DRV_OF_DEV	driver/hd.c	16;"	d	file:
DispAL	boot/loader.asm	/^DispAL:$/;"	l
DispInt	boot/loader.asm	/^DispInt:$/;"	l
DispMemInfo	boot/loader.asm	/^DispMemInfo:$/;"	l
DispReturn	boot/loader.asm	/^DispReturn:$/;"	l
DispStr	boot/boot.asm	/^DispStr:$/;"	l
DispStr	boot/loader.asm	/^DispStr:$/;"	l
DispStrRealMode	boot/loader.asm	/^DispStrRealMode:$/;"	l
END	include/keyboard.h	82;"	d
ENTER	include/keyboard.h	42;"	d
ENTRYOFFSET	Makefile	/^ENTRYOFFSET	=   0x400$/;"	m
ENTRYPOINT	Makefile	/^ENTRYPOINT	= 0x30400$/;"	m
ESC	include/keyboard.h	40;"	d
ETHER_IRQ	include/const.h	78;"	d
EXTERN	include/const.h	13;"	d
EXTERN	include/global.h	13;"	d
EXTERN	include/global.h	14;"	d
EXT_PART	include/hd.h	274;"	d
F1	include/keyboard.h	63;"	d
F10	include/keyboard.h	72;"	d
F11	include/keyboard.h	73;"	d
F12	include/keyboard.h	74;"	d
F2	include/keyboard.h	64;"	d
F3	include/keyboard.h	65;"	d
F4	include/keyboard.h	66;"	d
F5	include/keyboard.h	67;"	d
F6	include/keyboard.h	68;"	d
F7	include/keyboard.h	69;"	d
F8	include/keyboard.h	70;"	d
F9	include/keyboard.h	71;"	d
FALSE	include/const.h	21;"	d
FD	include/msg.h	54;"	d
FLAGS	include/msg.h	56;"	d
FLAG_ALT_L	include/keyboard.h	31;"	d
FLAG_ALT_R	include/keyboard.h	32;"	d
FLAG_BREAK	include/keyboard.h	25;"	d
FLAG_CTRL_L	include/keyboard.h	29;"	d
FLAG_CTRL_R	include/keyboard.h	30;"	d
FLAG_EXT	include/keyboard.h	26;"	d
FLAG_PAD	include/keyboard.h	33;"	d
FLAG_SHIFT_L	include/keyboard.h	27;"	d
FLAG_SHIFT_R	include/keyboard.h	28;"	d
FLASH	include/const.h	34;"	d
FLOPPY_IRQ	include/const.h	82;"	d
FSBUF_SIZE	fs/main.c	/^const int FSBUF_SIZE = 0x100000;$/;"	v
GATE	include/protect.h	/^}GATE;$/;"	t	typeref:struct:s_gate
GDT_SIZE	include/const.h	39;"	d
GET_TICKS	include/msg.h	/^	GET_TICKS,$/;"	e	enum:msgtype
GLOBAL_VARIABLES_HERE	kernel/global.c	8;"	d	file:
GRAY_CHAR	include/console.h	12;"	d
GREEN	include/const.h	32;"	d
GUI_L	include/keyboard.h	45;"	d
GUI_R	include/keyboard.h	46;"	d
GdtLen	boot/loader.asm	/^GdtLen		equ	$ - LABEL_GDT$/;"	d
GdtPtr	boot/loader.asm	/^GdtPtr		dw	GdtLen - 1				; 段界限$/;"	d
GetFATEntry	boot/boot.asm	/^GetFATEntry:$/;"	l
GetFATEntry	boot/loader.asm	/^GetFATEntry:$/;"	l
HARD_INT	include/msg.h	/^	HARD_INT=1,$/;"	e	enum:msgtype
HD_TIMEOUT	include/hd.h	261;"	d
HOME	include/keyboard.h	81;"	d
HZ	include/const.h	62;"	d
IDT_SIZE	include/const.h	40;"	d
INDEX_DUMMY	include/protect.h	68;"	d
INDEX_FLAT_C	include/protect.h	69;"	d
INDEX_FLAT_RW	include/protect.h	70;"	d
INDEX_LDT_C	include/protect.h	88;"	d
INDEX_LDT_FIRST	include/protect.h	73;"	d
INDEX_LDT_RW	include/protect.h	89;"	d
INDEX_TSS	include/protect.h	72;"	d
INDEX_VIDEO	include/protect.h	71;"	d
INODE_SIZE	include/fs.h	66;"	d
INSERT	include/keyboard.h	79;"	d
INTERRUPT	include/proc.h	84;"	d
INT_M_CTL	include/const.h	52;"	d
INT_M_CTLMASK	include/const.h	53;"	d
INT_S_CTL	include/const.h	54;"	d
INT_S_CTLMASK	include/const.h	55;"	d
INT_VECTOR_BOUNDS	include/protect.h	131;"	d
INT_VECTOR_BREAKPOINT	include/protect.h	129;"	d
INT_VECTOR_COPROC_ERR	include/protect.h	141;"	d
INT_VECTOR_COPROC_NOT	include/protect.h	133;"	d
INT_VECTOR_COPROC_SEG	include/protect.h	135;"	d
INT_VECTOR_DEBUG	include/protect.h	127;"	d
INT_VECTOR_DIVIDE	include/protect.h	126;"	d
INT_VECTOR_DOUBLE_FAULT	include/protect.h	134;"	d
INT_VECTOR_INVAL_OP	include/protect.h	132;"	d
INT_VECTOR_INVAL_TSS	include/protect.h	136;"	d
INT_VECTOR_IRQ0	include/protect.h	144;"	d
INT_VECTOR_IRQ8	include/protect.h	145;"	d
INT_VECTOR_NMI	include/protect.h	128;"	d
INT_VECTOR_OVERFLOW	include/protect.h	130;"	d
INT_VECTOR_PAGE_FAULT	include/protect.h	140;"	d
INT_VECTOR_PROTECTION	include/protect.h	139;"	d
INT_VECTOR_SEG_NOT	include/protect.h	137;"	d
INT_VECTOR_STACK_FAULT	include/protect.h	138;"	d
INT_VECTOR_SYS_CALL	include/protect.h	148;"	d
INT_VECTOR_SYS_CALL	kernel/syscall.asm	/^INT_VECTOR_SYS_CALL	equ	0x90$/;"	d
INVALID_DRIVER	include/proc.h	83;"	d
INVALID_INODE	include/fs.h	76;"	d
I_BLOCK_SPECIAL	include/fs.h	82;"	d
I_CHAR_SPECIAL	include/fs.h	84;"	d
I_DIRECTORY	include/fs.h	83;"	d
I_NAMED_PIPE	include/fs.h	85;"	d
I_REGULAR	include/fs.h	81;"	d
I_TYPE_MASK	include/fs.h	80;"	d
InitKernel	boot/loader.asm	/^InitKernel:	; 遍历每一个 Program Header，根据 Program Header 中的信息来确定把什么放进内存，放到什么位置，以及放多少。$/;"	l
KB_ACK	include/keyboard.h	14;"	d
KB_CMD	include/const.h	69;"	d
KB_DATA	include/const.h	66;"	d
KB_INPUT	include/keyboard.h	/^}KB_INPUT;$/;"	t	typeref:struct:s_kb
KB_IN_BYTES	include/keyboard.h	21;"	d
KEYBOARD_IRQ	include/const.h	76;"	d
KernelFileName	boot/loader.asm	/^KernelFileName		db	"KERNEL  BIN", 0	; KERNEL.BIN 之文件名$/;"	d
KillMotor	boot/loader.asm	/^KillMotor:$/;"	l
LABEL_CMP_FILENAME	boot/boot.asm	/^LABEL_CMP_FILENAME:$/;"	l
LABEL_CMP_FILENAME	boot/loader.asm	/^LABEL_CMP_FILENAME:$/;"	l
LABEL_DATA	boot/loader.asm	/^LABEL_DATA:$/;"	l
LABEL_DESC_FLAT_C	boot/loader.asm	/^LABEL_DESC_FLAT_C:		Descriptor             0,              0fffffh, DA_CR  | DA_32 | DA_LIMIT_4K			; 0 ~ 4G$/;"	l
LABEL_DESC_FLAT_RW	boot/loader.asm	/^LABEL_DESC_FLAT_RW:		Descriptor             0,              0fffffh, DA_DRW | DA_32 | DA_LIMIT_4K			; 0 ~ 4G$/;"	l
LABEL_DESC_VIDEO	boot/loader.asm	/^LABEL_DESC_VIDEO:		Descriptor	 0B8000h,               0ffffh, DA_DRW                         | DA_DPL3	; 显存首地址$/;"	l
LABEL_DIFFERENT	boot/boot.asm	/^LABEL_DIFFERENT:$/;"	l
LABEL_DIFFERENT	boot/loader.asm	/^LABEL_DIFFERENT:$/;"	l
LABEL_EVEN_2	boot/boot.asm	/^LABEL_EVEN_2:$/;"	l
LABEL_EVEN_2	boot/loader.asm	/^LABEL_EVEN_2:$/;"	l
LABEL_FILENAME_FOUND	boot/boot.asm	/^LABEL_FILENAME_FOUND:			; 找到 LOADER.BIN 后便来到这里继续$/;"	l
LABEL_FILENAME_FOUND	boot/loader.asm	/^LABEL_FILENAME_FOUND:			; 找到 KERNEL.BIN 后便来到这里继续$/;"	l
LABEL_FILE_LOADED	boot/boot.asm	/^LABEL_FILE_LOADED:$/;"	l
LABEL_FILE_LOADED	boot/loader.asm	/^LABEL_FILE_LOADED:$/;"	l
LABEL_GDT	boot/loader.asm	/^LABEL_GDT:			Descriptor             0,                    0, 0						; 空描述符$/;"	l
LABEL_GET_FAT_ENRY_OK	boot/boot.asm	/^LABEL_GET_FAT_ENRY_OK:$/;"	l
LABEL_GET_FAT_ENRY_OK	boot/loader.asm	/^LABEL_GET_FAT_ENRY_OK:$/;"	l
LABEL_GOON_LOADING_FILE	boot/boot.asm	/^LABEL_GOON_LOADING_FILE:$/;"	l
LABEL_GOON_LOADING_FILE	boot/loader.asm	/^LABEL_GOON_LOADING_FILE:$/;"	l
LABEL_GOTO_NEXT_SECTOR_IN_ROOT_DIR	boot/boot.asm	/^LABEL_GOTO_NEXT_SECTOR_IN_ROOT_DIR:$/;"	l
LABEL_GOTO_NEXT_SECTOR_IN_ROOT_DIR	boot/loader.asm	/^LABEL_GOTO_NEXT_SECTOR_IN_ROOT_DIR:$/;"	l
LABEL_GO_ON	boot/boot.asm	/^LABEL_GO_ON:$/;"	l
LABEL_GO_ON	boot/loader.asm	/^LABEL_GO_ON:$/;"	l
LABEL_NO_KERNELBIN	boot/loader.asm	/^LABEL_NO_KERNELBIN:$/;"	l
LABEL_NO_LOADERBIN	boot/boot.asm	/^LABEL_NO_LOADERBIN:$/;"	l
LABEL_PM_START	boot/loader.asm	/^LABEL_PM_START:$/;"	l
LABEL_SEARCH_FOR_KERNELBIN	boot/loader.asm	/^LABEL_SEARCH_FOR_KERNELBIN:$/;"	l
LABEL_SEARCH_FOR_LOADERBIN	boot/boot.asm	/^LABEL_SEARCH_FOR_LOADERBIN:$/;"	l
LABEL_SEARCH_IN_ROOT_DIR_BEGIN	boot/boot.asm	/^LABEL_SEARCH_IN_ROOT_DIR_BEGIN:$/;"	l
LABEL_SEARCH_IN_ROOT_DIR_BEGIN	boot/loader.asm	/^LABEL_SEARCH_IN_ROOT_DIR_BEGIN:$/;"	l
LABEL_START	boot/boot.asm	/^LABEL_START:	$/;"	l
LABEL_START	boot/loader.asm	/^LABEL_START:			; <--- 从这里开始 *************$/;"	l
LD	Makefile	/^LD		= ld$/;"	m
LDFLAGS	Makefile	/^LDFLAGS		= -m elf_i386 -s -Ttext $(ENTRYPOINT)$/;"	m
LDT_SIZE	include/protect.h	87;"	d
LED_CODE	include/keyboard.h	13;"	d
LEFT	include/keyboard.h	87;"	d
LSEEK	include/msg.h	/^	   OPEN, CLOSE, READ, WRITE, LSEEK, STAT, UNLINK,   $/;"	e	enum:msgtype
LoadMessage	boot/loader.asm	/^LoadMessage:		db	"Loading  "$/;"	d
LoaderFileName	boot/boot.asm	/^LoaderFileName		db	"LOADER  BIN", 0	; LOADER.BIN 之文件名$/;"	d
MAGIC_V1	include/fs.h	13;"	d
MAG_CH_ASSERT	include/err.h	17;"	d
MAG_CH_PANIC	include/err.h	18;"	d
MAJOR	include/drive.h	14;"	d
MAJOR_SHIFT	include/drive.h	12;"	d
MAKE_COLOR	include/const.h	36;"	d
MAKE_DEV	include/drive.h	13;"	d
MAKE_DEVICE_REG	include/hd.h	267;"	d
MAP_COLS	include/keyboard.h	22;"	d
MASK_RAW	include/keyboard.h	35;"	d
MAX_DRIVES	include/hd.h	234;"	d
MAX_FILENAME_LEN	include/fs.h	67;"	d
MAX_PATH_LEN	include/fs.h	22;"	d
MAX_PRIM_INDEX	include/hd.h	240;"	d
MAX_SUB_PARTITIONS	include/hd.h	241;"	d
MESSAGE	include/msg.h	/^}MESSAGE;$/;"	t	typeref:struct:mess
MINOR	include/drive.h	15;"	d
MINOR_BOOT	include/config.h	5;"	d
MINOR_hd1a	include/hd.h	278;"	d
MINOR_hd2a	include/hd.h	279;"	d
MemChkBuf	boot/loader.asm	/^MemChkBuf		equ	BaseOfLoaderPhyAddr + _MemChkBuf$/;"	d
MemCpy	boot/loader.asm	/^MemCpy:$/;"	l
Message1	boot/boot.asm	/^Message1		db	"Ready.   "; 9字节, 不够则用空格补齐. 序号 1$/;"	d
Message1	boot/loader.asm	/^Message1		db	"Ready.   "$/;"	d
Message2	boot/boot.asm	/^Message2		db	"No LOADER"; 9字节, 不够则用空格补齐. 序号 2$/;"	d
Message2	boot/loader.asm	/^Message2		db	"No KERNEL"$/;"	d
MessageLength	boot/boot.asm	/^MessageLength		equ	9$/;"	d
MessageLength	boot/loader.asm	/^MessageLength		equ	9$/;"	d
NAME_LEN	include/msg.h	57;"	d
NO_DEV	include/drive.h	5;"	d
NO_PART	include/hd.h	273;"	d
NO_TASK	include/proc.h	90;"	d
NR_CONSOLE	include/console.h	4;"	d
NR_DEFAULT_FILE_SECTS	include/fs.h	75;"	d
NR_FILES	include/fs.h	15;"	d
NR_FILE_DESC	include/fs.h	16;"	d
NR_INODE	include/fs.h	17;"	d
NR_IRQ	include/const.h	74;"	d
NR_PART_PER_DRIVE	include/hd.h	235;"	d
NR_PRIM_PER_DRIVE	include/hd.h	238;"	d
NR_PROCS	include/proc.h	80;"	d
NR_SCAN_CODES	include/keyboard.h	23;"	d
NR_SUB_PER_DRIVE	include/hd.h	237;"	d
NR_SUB_PER_PART	include/hd.h	236;"	d
NR_SUPER_BLOCK	include/fs.h	18;"	d
NR_SYS_CALL	include/const.h	101;"	d
NR_TASKS	include/proc.h	78;"	d
NR_TTY	include/tty.h	6;"	d
NR_USER_PROCS	include/proc.h	79;"	d
NUM_LOCK	include/keyboard.h	59;"	d
OBJS	Makefile	/^OBJS		= kernel\/kernel.o kernel\/syscall.o kernel\/start.o kernel\/main.o\\$/;"	m
OFFSET	include/msg.h	64;"	d
OPEN	include/msg.h	/^	   OPEN, CLOSE, READ, WRITE, LSEEK, STAT, UNLINK,   $/;"	e	enum:msgtype
ORANGE_PART	include/hd.h	275;"	d
O_CREAT	include/nostdio.h	7;"	d
O_RDWR	include/nostdio.h	8;"	d
PAD_0	include/keyboard.h	102;"	d
PAD_1	include/keyboard.h	103;"	d
PAD_2	include/keyboard.h	104;"	d
PAD_3	include/keyboard.h	105;"	d
PAD_4	include/keyboard.h	106;"	d
PAD_5	include/keyboard.h	107;"	d
PAD_6	include/keyboard.h	108;"	d
PAD_7	include/keyboard.h	109;"	d
PAD_8	include/keyboard.h	110;"	d
PAD_9	include/keyboard.h	111;"	d
PAD_DEL	include/keyboard.h	122;"	d
PAD_DOT	include/keyboard.h	101;"	d
PAD_DOWN	include/keyboard.h	113;"	d
PAD_END	include/keyboard.h	117;"	d
PAD_ENTER	include/keyboard.h	100;"	d
PAD_HOME	include/keyboard.h	116;"	d
PAD_INS	include/keyboard.h	120;"	d
PAD_LEFT	include/keyboard.h	114;"	d
PAD_MID	include/keyboard.h	121;"	d
PAD_MINUS	include/keyboard.h	98;"	d
PAD_PAGEDOWN	include/keyboard.h	119;"	d
PAD_PAGEUP	include/keyboard.h	118;"	d
PAD_PLUS	include/keyboard.h	99;"	d
PAD_RIGHT	include/keyboard.h	115;"	d
PAD_SLASH	include/keyboard.h	96;"	d
PAD_STAR	include/keyboard.h	97;"	d
PAD_UP	include/keyboard.h	112;"	d
PAGEDOWN	include/keyboard.h	84;"	d
PAGEUP	include/keyboard.h	83;"	d
PARTITION_ENTRY	include/hd.h	/^} PARTITION_ENTRY;$/;"	v	typeref:struct:part_entry
PARTITION_TABLE_OFFSET	include/hd.h	262;"	d
PATHNAME	include/msg.h	55;"	d
PAUSEBREAK	include/keyboard.h	78;"	d
PORT_8042_CONTROL	include/keyboard.h	15;"	d
PORT_8042_DATA	include/keyboard.h	16;"	d
POSITION	include/msg.h	62;"	d
POWER	include/keyboard.h	91;"	d
PRINTER_IRQ	include/const.h	83;"	d
PRINTSCREEN	include/keyboard.h	77;"	d
PRIVATE	include/const.h	17;"	d
PRIVILEGE_KRNL	include/const.h	43;"	d
PRIVILEGE_TASK	include/const.h	44;"	d
PRIVILEGE_USER	include/const.h	45;"	d
PROCESS	include/proc.h	/^}PROCESS;$/;"	t	typeref:struct:proc
PROC_NR	include/msg.h	60;"	d
PUBLIC	include/const.h	16;"	d
P_EXTENDED	include/hd.h	272;"	d
P_PRIMARY	include/hd.h	271;"	d
RATE_GENERATOR	include/const.h	60;"	d
RD_SECT	include/fs.h	9;"	d
READ	include/msg.h	/^	   OPEN, CLOSE, READ, WRITE, LSEEK, STAT, UNLINK,   $/;"	e	enum:msgtype
RECEIVE	include/msg.h	37;"	d
RECEIVING	include/proc.h	113;"	d
RED	include/const.h	31;"	d
RED_CHAR	include/console.h	13;"	d
REG_ALT_STATUS	include/hd.h	211;"	d
REG_CMD	include/hd.h	167;"	d
REG_DATA	include/hd.h	99;"	d
REG_DEVICE	include/hd.h	125;"	d
REG_DEV_CTRL	include/hd.h	191;"	d
REG_DRV_ADDR	include/hd.h	216;"	d
REG_ERROR	include/hd.h	101;"	d
REG_FEATURES	include/hd.h	100;"	d
REG_LBA_HIGH	include/hd.h	124;"	d
REG_LBA_LOW	include/hd.h	122;"	d
REG_LBA_MID	include/hd.h	123;"	d
REG_NSECTOR	include/hd.h	121;"	d
REG_STATUS	include/hd.h	142;"	d
REQUEST	include/msg.h	59;"	d
RETVAL	include/msg.h	69;"	d
RIGHT	include/keyboard.h	88;"	d
ROOT_DEV	include/hd.h	280;"	d
ROOT_INODE	include/fs.h	77;"	d
RPL_KRNL	include/const.h	47;"	d
RPL_TASK	include/const.h	48;"	d
RPL_USER	include/const.h	49;"	d
RS232_IRQ	include/const.h	80;"	d
ReadSector	boot/boot.asm	/^ReadSector:$/;"	l
ReadSector	boot/loader.asm	/^ReadSector:$/;"	l
SA_RPL0	include/protect.h	116;"	d
SA_RPL1	include/protect.h	117;"	d
SA_RPL2	include/protect.h	118;"	d
SA_RPL3	include/protect.h	119;"	d
SA_RPL_MASK	include/protect.h	115;"	d
SA_TIG	include/protect.h	122;"	d
SA_TIL	include/protect.h	123;"	d
SA_TI_MASK	include/protect.h	121;"	d
SCREEN_SIZE	include/console.h	6;"	d
SCREEN_WIDETH	include/console.h	5;"	d
SCROLL_DOWN	include/console.h	9;"	d
SCROLL_LOCK	include/keyboard.h	60;"	d
SCROLL_UP	include/console.h	8;"	d
SECONDARY_IRQ	include/const.h	79;"	d
SECTOR_SIZE	driver/hd.c	11;"	d	file:
SECTOR_SIZE	fs/main.c	17;"	d	file:
SECTOR_SIZE	fs/misc.c	7;"	d	file:
SECTOR_SIZE	fs/opera.c	21;"	d	file:
SECTOR_SIZE_SHIFT	driver/hd.c	12;"	d	file:
SECTOR_SIZE_SHIFT	fs/opera.c	23;"	d	file:
SEEK_CUR	include/nostdio.h	11;"	d
SEEK_END	include/nostdio.h	12;"	d
SEEK_SET	include/nostdio.h	10;"	d
SELECTOR_DUMMY	include/protect.h	75;"	d
SELECTOR_FLAT_C	include/protect.h	76;"	d
SELECTOR_FLAT_RW	include/protect.h	77;"	d
SELECTOR_KERNEL_CS	include/protect.h	82;"	d
SELECTOR_KERNEL_DS	include/protect.h	83;"	d
SELECTOR_KERNEL_GS	include/protect.h	84;"	d
SELECTOR_LDT_FIRST	include/protect.h	80;"	d
SELECTOR_TSS	include/protect.h	79;"	d
SELECTOR_VIDEO	include/protect.h	78;"	d
SEND	include/msg.h	36;"	d
SENDING	include/proc.h	112;"	d
SHIFT_L	include/keyboard.h	50;"	d
SHIFT_R	include/keyboard.h	51;"	d
SLEEP	include/keyboard.h	92;"	d
STACK_FRAME	include/proc.h	/^}STACK_FRAME;$/;"	t	typeref:struct:s_stackframe
STACK_SIZE_FS	include/proc.h	96;"	d
STACK_SIZE_HD	include/proc.h	95;"	d
STACK_SIZE_SYS	include/proc.h	94;"	d
STACK_SIZE_TESTA	include/proc.h	97;"	d
STACK_SIZE_TESTB	include/proc.h	98;"	d
STACK_SIZE_TESTC	include/proc.h	99;"	d
STACK_SIZE_TOTAL	include/proc.h	102;"	d
STACK_SIZE_TTY	include/proc.h	93;"	d
START_ADDR_H	include/const.h	93;"	d
START_ADDR_L	include/const.h	94;"	d
STAT	include/msg.h	/^	   OPEN, CLOSE, READ, WRITE, LSEEK, STAT, UNLINK,   $/;"	e	enum:msgtype
STATUS_BSY	include/hd.h	158;"	d
STATUS_CORR	include/hd.h	163;"	d
STATUS_DFSE	include/hd.h	160;"	d
STATUS_DRDY	include/hd.h	159;"	d
STATUS_DRQ	include/hd.h	162;"	d
STATUS_DSC	include/hd.h	161;"	d
STATUS_ERR	include/hd.h	165;"	d
STATUS_IDX	include/hd.h	164;"	d
STR_DEFAULT_LEN	include/string.h	8;"	d
SUPER_BLOCK_SIZE	include/fs.h	51;"	d
SYSCALL_RET	include/msg.h	/^	SYSCALL_RET,   $/;"	e	enum:msgtype
SelectorFlatC	boot/loader.asm	/^SelectorFlatC		equ	LABEL_DESC_FLAT_C	- LABEL_GDT$/;"	d
SelectorFlatRW	boot/loader.asm	/^SelectorFlatRW		equ	LABEL_DESC_FLAT_RW	- LABEL_GDT$/;"	d
SelectorVideo	boot/loader.asm	/^SelectorVideo		equ	LABEL_DESC_VIDEO	- LABEL_GDT + SA_RPL3$/;"	d
SetupPaging	boot/loader.asm	/^SetupPaging:$/;"	l
StackSpace	boot/loader.asm	/^StackSpace:	times	1000h	db	0$/;"	l
StackSpace	kernel/kernel.asm	/^StackSpace		resb	2 * 1024$/;"	l
StackTop	kernel/kernel.asm	/^StackTop:		; 栈顶$/;"	l
TAB	include/keyboard.h	41;"	d
TASK	include/proc.h	/^}TASK;$/;"	t	typeref:struct:s_task
TASK_FS	include/proc.h	88;"	d
TASK_HD	include/proc.h	87;"	d
TASK_SYS	include/proc.h	86;"	d
TASK_TTY	include/proc.h	85;"	d
TIMER0	include/const.h	58;"	d
TIMER_FREQ	include/const.h	61;"	d
TIMER_MODE	include/const.h	59;"	d
TINIXBOOT	Makefile	/^TINIXBOOT	= boot\/boot.bin boot\/loader.bin$/;"	m
TINIXKERNEL	Makefile	/^TINIXKERNEL	= kernel.bin$/;"	m
TRUE	include/const.h	20;"	d
TSS	include/protect.h	/^}TSS;$/;"	t	typeref:struct:s_tss
TTY	include/tty.h	/^}TTY;$/;"	t	typeref:struct:tty
TTY_BUFFER_SIZE	include/tty.h	4;"	d
TestA	kernel/main.c	/^void TestA()$/;"	f
TestB	kernel/main.c	/^void TestB()$/;"	f
TestC	kernel/main.c	/^void TestC()$/;"	f
TopOfStack	boot/loader.asm	/^TopOfStack	equ	BaseOfLoaderPhyAddr + $	; 栈顶$/;"	d
UNLINK	include/msg.h	/^	   OPEN, CLOSE, READ, WRITE, LSEEK, STAT, UNLINK,   $/;"	e	enum:msgtype
UP	include/keyboard.h	85;"	d
V_MEM_BASE	include/const.h	97;"	d
V_MEM_SIZE	include/const.h	98;"	d
WAKE	include/keyboard.h	93;"	d
WHENCE	include/msg.h	65;"	d
WHITE	include/const.h	30;"	d
WRITE	include/msg.h	/^	   OPEN, CLOSE, READ, WRITE, LSEEK, STAT, UNLINK,   $/;"	e	enum:msgtype
WR_SECT	include/fs.h	10;"	d
XT_WINI_IRQ	include/const.h	81;"	d
_ARDStruct	boot/loader.asm	/^_ARDStruct:			; Address Range Descriptor Structure$/;"	l
_MemChkBuf	boot/loader.asm	/^_MemChkBuf:	times	256	db	0$/;"	l
_NOSTDIO_H	include/nostdio.h	2;"	d
_NR_printx	kernel/syscall.asm	/^_NR_printx		equ	0	; 要跟 global.c 中 sys_call_table 的定义相对应！$/;"	d
_NR_sendrec	kernel/syscall.asm	/^_NR_sendrec			equ	1$/;"	d
_PROC_H_	include/proc.h	2;"	d
_PROTO_H	include/proto.h	2;"	d
_STRING_H	include/string.h	2;"	d
_TINIX_CONST_H_	include/const.h	9;"	d
_TINIX_KEYBOARD_H_	include/keyboard.h	9;"	d
_TINIX_KEYMAP_H_	include/keymap.h	14;"	d
_TINIX_PROTECT_H_	include/protect.h	9;"	d
_TINIX_TYPE_H_	include/type.h	9;"	d
_TTY_H_	include/tty.h	2;"	d
__CONFIG_H__	include/config.h	2;"	d
__DEBUG_H__	include/debug.h	2;"	d
__DRIVE_H__	include/drive.h	3;"	d
__ERR_H__	include/err.h	2;"	d
__FS_H__	include/fs.h	2;"	d
__GLOBAL_H__	include/global.h	10;"	d
__HD_H__	include/hd.h	2;"	d
__MSG__H__	include/msg.h	2;"	d
____MATH_H__	include/math.h	2;"	d
_dwBaseAddrHigh	boot/loader.asm	/^	_dwBaseAddrHigh:	dd	0$/;"	d
_dwBaseAddrLow	boot/loader.asm	/^	_dwBaseAddrLow:		dd	0$/;"	d
_dwDispPos	boot/loader.asm	/^_dwDispPos:			dd	(80 * 6 + 0) * 2	; 屏幕第 6 行, 第 0 列。$/;"	d
_dwLengthHigh	boot/loader.asm	/^	_dwLengthHigh:		dd	0$/;"	d
_dwLengthLow	boot/loader.asm	/^	_dwLengthLow:		dd	0$/;"	d
_dwMCRNumber	boot/loader.asm	/^_dwMCRNumber:			dd	0	; Memory Check Result$/;"	d
_dwMemSize	boot/loader.asm	/^_dwMemSize:			dd	0$/;"	d
_dwType	boot/loader.asm	/^	_dwType:		dd	0$/;"	d
_start	kernel/kernel.asm	/^_start:$/;"	l
_szMemChkTitle	boot/loader.asm	/^_szMemChkTitle:			db	"BaseAddrL BaseAddrH LengthLow LengthHigh   Type", 0Ah, 0$/;"	d
_szRAMSize	boot/loader.asm	/^_szRAMSize:			db	"RAM size:", 0$/;"	d
_szReturn	boot/loader.asm	/^_szReturn:			db	0Ah, 0$/;"	d
_unused	include/fs.h	/^	t_8 _unused[16];$/;"	m	struct:inode
alloc_imap_bit	fs/opera.c	/^static int alloc_imap_bit(int dev)$/;"	f	file:
alloc_smap_bit	fs/opera.c	/^static int alloc_smap_bit(int dev, int nr_sects_to_alloc)$/;"	f	file:
alt_l	kernel/keyboard.c	/^PRIVATE int alt_l;$/;"	v
alt_r	kernel/keyboard.c	/^PRIVATE int alt_r;$/;"	v
assert	include/err.h	12;"	d
assert	include/err.h	9;"	d
assertion_failure	lib/err.c	/^void assertion_failure(char *exp, char *file, char * base_file, int line)$/;"	f
attr	include/protect.h	/^	t_8	attr;		\/* P(1) DPL(2) DT(1) TYPE(4) *\/$/;"	m	struct:s_gate
attr1	include/protect.h	/^	t_8	attr1;			\/* P(1) DPL(2) DT(1) TYPE(4) *\/$/;"	m	struct:descriptor
bOdd	boot/boot.asm	/^bOdd			db	0		; 奇数还是偶数$/;"	d
bOdd	boot/loader.asm	/^bOdd			db	0		; 奇数还是偶数$/;"	d
backlink	include/protect.h	/^	t_32	backlink;$/;"	m	struct:s_tss
base	include/hd.h	/^	t_32	base;	\/* # of start sector (NOT byte offset, but SECTOR) *\/$/;"	m	struct:part_info
base_high	include/protect.h	/^	t_8	base_high;		\/* Base *\/$/;"	m	struct:descriptor
base_low	include/protect.h	/^	t_16	base_low;		\/* Base *\/$/;"	m	struct:descriptor
base_mid	include/protect.h	/^	t_8	base_mid;		\/* Base *\/$/;"	m	struct:descriptor
begin_adr	include/console.h	/^	unsigned int begin_adr;$/;"	m	struct:s_console
bits	kernel/kernel.asm	/^bits 32$/;"	l
bits	kernel/syscall.asm	/^bits 32$/;"	l
block	kernel/proc.c	/^void block(struct proc*p)$/;"	f
boot_ind	include/hd.h	/^	t_8 boot_ind;		\/**$/;"	m	struct:part_entry
bounds_check	kernel/kernel.asm	/^bounds_check:$/;"	l
breakpoint_exception	kernel/kernel.asm	/^breakpoint_exception:$/;"	l
buf	include/keyboard.h	/^	char buf[KB_IN_BYTES];$/;"	m	struct:s_kb
buffer	include/tty.h	/^	t_32	buffer[TTY_BUFFER_SIZE];$/;"	m	struct:tty
caps_lock	kernel/keyboard.c	/^PRIVATE int caps_lock;$/;"	v
caps_lock	kernel/keyboard.c	/^static int caps_lock;$/;"	v	file:
clock_handler	kernel/clock.c	/^PUBLIC void clock_handler(int irq)$/;"	f
clock_int_msg	kernel/kernel.asm	/^clock_int_msg		db	"^", 0$/;"	d
close	lib/unistd.c	/^int  close(int fd)$/;"	f
code_with_E0	kernel/keyboard.c	/^PRIVATE int code_with_E0=0;$/;"	v
column	kernel/keyboard.c	/^PRIVATE int column;$/;"	v
command	include/hd.h	/^	t_8	command;$/;"	m	struct:hd_cmd
console_p	include/tty.h	/^	struct s_console *console_p;$/;"	m	struct:tty	typeref:struct:tty::s_console
console_table	kernel/global.c	/^CONSOLE		console_table[NR_CONSOLE];$/;"	v
copr_error	kernel/kernel.asm	/^copr_error:$/;"	l
copr_not_available	kernel/kernel.asm	/^copr_not_available:$/;"	l
copr_seg_overrun	kernel/kernel.asm	/^copr_seg_overrun:$/;"	l
count	include/keyboard.h	/^	int count;$/;"	m	struct:s_kb
count	include/tty.h	/^	int 	count;$/;"	m	struct:tty
cr3	include/protect.h	/^	t_32	cr3;$/;"	m	struct:s_tss
create_file	fs/opera.c	/^static struct inode *create_file(char *path, int flags)$/;"	f	file:
cs	include/proc.h	/^	t_32	cs;		\/*  ┃						│			*\/$/;"	m	struct:s_stackframe
cs	include/protect.h	/^	t_32	cs;$/;"	m	struct:s_tss
csinit	kernel/kernel.asm	/^csinit:		; “这个跳转指令强制使用刚刚初始化的结构”――<<OS:D&I 2nd>> P90.$/;"	l
cstart	kernel/start.c	/^PUBLIC void cstart()$/;"	f
ctrl_l	kernel/keyboard.c	/^PRIVATE int ctrl_l;$/;"	v
ctrl_r	kernel/keyboard.c	/^PRIVATE int ctrl_r;$/;"	v
current_start_addr	include/console.h	/^	unsigned int current_start_addr;$/;"	m	struct:s_console
current_tty	include/tty.h	/^TTY * current_tty;$/;"	v
cursor_location	include/console.h	/^	unsigned int cursor_location;$/;"	m	struct:s_console
dcount	include/protect.h	/^	t_8	dcount;		\/* 该字段只在调用门描述符中有效。$/;"	m	struct:s_gate
dd_map	driver/driver.c	/^struct dev_drv_map dd_map[]={                                                                                                                    $/;"	v	typeref:struct:dev_drv_map
deadlock	kernel/proc.c	/^static deadlock(int src,int dest)$/;"	f	file:
dec	boot/boot.asm	/^	dec	dx					; ┛就跳到下一个 Sector$/;"	d
dec	boot/boot.asm	/^dec	cx$/;"	l
dec	boot/loader.asm	/^	dec	dx					; ┛$/;"	d
delay	lib/klib.c	/^void delay(int time)$/;"	f
descriptor	include/protect.h	/^typedef struct descriptor		\/* 共 8 个字节 *\/$/;"	s
dev_drv_map	include/drive.h	/^struct dev_drv_map{$/;"	s
device	include/hd.h	/^	t_8	device;$/;"	m	struct:hd_cmd
dir_ent_fname_off	include/fs.h	/^	t_32 dir_ent_fname_off;$/;"	m	struct:super_block
dir_ent_inode_off	include/fs.h	/^	t_32 dir_ent_inode_off;$/;"	m	struct:super_block
dir_ent_size	include/fs.h	/^	t_32 dir_ent_size;$/;"	m	struct:super_block
dir_entry	include/fs.h	/^struct dir_entry {$/;"	s
dis_already	lib/klib.asm	/^dis_already:$/;"	l
disable_0	lib/klib.asm	/^disable_0:$/;"	l
disable_8	lib/klib.asm	/^disable_8:$/;"	l
disable_int	lib/klib.asm	/^disable_int:$/;"	l
disable_irq	lib/klib.asm	/^disable_irq:$/;"	l
disp_color_str	lib/klib.asm	/^disp_color_str:$/;"	l
disp_int	lib/klib.c	/^void disp_int(int input)$/;"	f
disp_pos	include/global.h	/^EXTERN	int		disp_pos;$/;"	v
disp_str	lib/klib.asm	/^disp_str:$/;"	l
divide_error	kernel/kernel.asm	/^divide_error:$/;"	l
do_close	fs/opera.c	/^int do_close()$/;"	f
do_open	fs/opera.c	/^int do_open()$/;"	f
do_rw	fs/opera.c	/^int do_rw()$/;"	f
double_fault	kernel/kernel.asm	/^double_fault:$/;"	l
driver_nr	include/drive.h	/^	int driver_nr;$/;"	m	struct:dev_drv_map
ds	include/proc.h	/^	t_32	ds;		\/* ┃						│			*\/$/;"	m	struct:s_stackframe
ds	include/protect.h	/^	t_32	ds;$/;"	m	struct:s_tss
dump_msg	kernel/proc.c	/^PUBLIC void dump_msg(const char * title, MESSAGE* m)$/;"	f
dw	boot/boot.asm	/^dw 	0xaa55				; 结束标志$/;"	l
dwBaseAddrHigh	boot/loader.asm	/^	dwBaseAddrHigh	equ	BaseOfLoaderPhyAddr + _dwBaseAddrHigh$/;"	d
dwBaseAddrLow	boot/loader.asm	/^	dwBaseAddrLow	equ	BaseOfLoaderPhyAddr + _dwBaseAddrLow$/;"	d
dwDispPos	boot/loader.asm	/^dwDispPos		equ	BaseOfLoaderPhyAddr + _dwDispPos$/;"	d
dwKernelSize	boot/loader.asm	/^dwKernelSize		dd	0		; KERNEL.BIN 文件大小$/;"	d
dwLengthHigh	boot/loader.asm	/^	dwLengthHigh	equ	BaseOfLoaderPhyAddr + _dwLengthHigh$/;"	d
dwLengthLow	boot/loader.asm	/^	dwLengthLow	equ	BaseOfLoaderPhyAddr + _dwLengthLow$/;"	d
dwMCRNumber	boot/loader.asm	/^dwMCRNumber		equ	BaseOfLoaderPhyAddr + _dwMCRNumber$/;"	d
dwMemSize	boot/loader.asm	/^dwMemSize		equ	BaseOfLoaderPhyAddr + _dwMemSize$/;"	d
dwType	boot/loader.asm	/^	dwType		equ	BaseOfLoaderPhyAddr + _dwType$/;"	d
eax	include/proc.h	/^	t_32	eax;		\/* ┛						│			*\/$/;"	m	struct:s_stackframe
eax	include/protect.h	/^	t_32	eax;$/;"	m	struct:s_tss
ebp	include/proc.h	/^	t_32	ebp;		\/* ┃						│			*\/$/;"	m	struct:s_stackframe
ebp	include/protect.h	/^	t_32	ebp;$/;"	m	struct:s_tss
ebx	include/proc.h	/^	t_32	ebx;		\/* ┃						↑栈从高地址往低地址增长*\/		$/;"	m	struct:s_stackframe
ebx	include/protect.h	/^	t_32	ebx;$/;"	m	struct:s_tss
ecx	include/proc.h	/^	t_32	ecx;		\/* ┃						│			*\/$/;"	m	struct:s_stackframe
ecx	include/protect.h	/^	t_32	ecx;$/;"	m	struct:s_tss
edi	include/proc.h	/^	t_32	edi;		\/* ┃						│			*\/$/;"	m	struct:s_stackframe
edi	include/protect.h	/^	t_32	edi;$/;"	m	struct:s_tss
edx	include/proc.h	/^	t_32	edx;		\/* ┃						│			*\/$/;"	m	struct:s_stackframe
edx	include/protect.h	/^	t_32	edx;$/;"	m	struct:s_tss
eflags	include/proc.h	/^	t_32	eflags;		\/*  ┣ these are pushed by CPU during interrupt	│			*\/$/;"	m	struct:s_stackframe
eip	include/proc.h	/^	t_32	eip;		\/*  ┓						│			*\/$/;"	m	struct:s_stackframe
eip	include/protect.h	/^	t_32	eip;$/;"	m	struct:s_tss
enable_0	lib/klib.asm	/^enable_0:$/;"	l
enable_8	lib/klib.asm	/^enable_8:$/;"	l
enable_int	lib/klib.asm	/^enable_int:$/;"	l
enable_irq	lib/klib.asm	/^enable_irq:$/;"	l
end_cyl	include/hd.h	/^	t_8 end_cyl;		\/**$/;"	m	struct:part_entry
end_head	include/hd.h	/^	t_8 end_head;		\/**$/;"	m	struct:part_entry
end_sector	include/hd.h	/^	t_8 end_sector;		\/**$/;"	m	struct:part_entry
es	include/proc.h	/^	t_32	es;		\/* ┃						│			*\/$/;"	m	struct:s_stackframe
es	include/protect.h	/^	t_32	es;$/;"	m	struct:s_tss
esi	include/proc.h	/^	t_32	esi;		\/* ┣ pushed by save()				│			*\/$/;"	m	struct:s_stackframe
esi	include/protect.h	/^	t_32	esi;$/;"	m	struct:s_tss
esp	include/proc.h	/^	t_32	esp;		\/*  ┃						│			*\/$/;"	m	struct:s_stackframe
esp	include/protect.h	/^	t_32	esp;$/;"	m	struct:s_tss
esp0	include/protect.h	/^	t_32	esp0;		\/* stack pointer to use during interrupt *\/$/;"	m	struct:s_tss
esp1	include/protect.h	/^	t_32	esp1;$/;"	m	struct:s_tss
esp2	include/protect.h	/^	t_32	esp2;$/;"	m	struct:s_tss
exception	kernel/kernel.asm	/^exception:$/;"	l
exception_handler	kernel/protect.c	/^PUBLIC void exception_handler(int vec_no, int err_code, int eip, int cs, int eflags)$/;"	f
extern	kernel/kernel.asm	/^extern	clock_handler$/;"	l
extern	kernel/kernel.asm	/^extern	cstart$/;"	l
extern	kernel/kernel.asm	/^extern	delay$/;"	l
extern	kernel/kernel.asm	/^extern	disp_pos$/;"	l
extern	kernel/kernel.asm	/^extern	disp_str$/;"	l
extern	kernel/kernel.asm	/^extern	exception_handler$/;"	l
extern	kernel/kernel.asm	/^extern	gdt_ptr$/;"	l
extern	kernel/kernel.asm	/^extern	idt_ptr$/;"	l
extern	kernel/kernel.asm	/^extern	irq_table$/;"	l
extern	kernel/kernel.asm	/^extern	k_reenter$/;"	l
extern	kernel/kernel.asm	/^extern	p_proc_ready$/;"	l
extern	kernel/kernel.asm	/^extern	spurious_irq$/;"	l
extern	kernel/kernel.asm	/^extern	sys_call_table$/;"	l
extern	kernel/kernel.asm	/^extern	tinix_main$/;"	l
extern	kernel/kernel.asm	/^extern	tss$/;"	l
extern	lib/klib.asm	/^extern	disp_pos$/;"	l
f_desc_table	fs/main.c	/^struct file_desc    f_desc_table[NR_FILE_DESC];$/;"	v	typeref:struct:file_desc
fd_inode	include/fs.h	/^	struct inode* fd_inode;$/;"	m	struct:file_desc	typeref:struct:file_desc::inode
fd_mode	include/fs.h	/^	int fd_mode;$/;"	m	struct:file_desc
fd_pos	include/fs.h	/^	int fd_pos;$/;"	m	struct:file_desc
features	include/hd.h	/^	t_8	features;$/;"	m	struct:hd_cmd
file_desc	include/fs.h	/^struct file_desc{$/;"	s
filp	include/proc.h	/^	struct	file_desc * filp[NR_FILES];$/;"	m	struct:proc	typeref:struct:proc::file_desc
flags	include/protect.h	/^	t_32	flags;$/;"	m	struct:s_tss
fs	include/proc.h	/^	t_32	fs;		\/* ┃						│			*\/$/;"	m	struct:s_stackframe
fs	include/protect.h	/^	t_32	fs;$/;"	m	struct:s_tss
fs_msg	fs/main.c	/^MESSAGE fs_msg;$/;"	v
fsbuf	fs/main.c	/^t_8 *fsbuf = (t_8 *)0x600000;$/;"	v
gdt	include/global.h	/^EXTERN	DESCRIPTOR	gdt[GDT_SIZE];$/;"	v
gdt_ptr	include/global.h	/^EXTERN	t_8		gdt_ptr[6];	\/\/ 0~15:Limit  16~47:Base$/;"	v
general_protection	kernel/kernel.asm	/^general_protection:$/;"	l
get_byte_from_kbuf	kernel/keyboard.c	/^PRIVATE t_8 get_byte_from_kbuf()$/;"	f
get_inode	fs/misc.c	/^struct inode * get_inode(int dev, int num)$/;"	f
get_part_table	driver/hd.c	/^static void get_part_table(int drive, int sector_nr, struct part_entry *entry)$/;"	f	file:
get_super_block	fs/main.c	/^struct super_block *get_super_block(int dev)$/;"	f
get_ticks	kernel/main.c	/^int get_ticks()$/;"	f
global	kernel/kernel.asm	/^global	bounds_check$/;"	l
global	kernel/kernel.asm	/^global	breakpoint_exception$/;"	l
global	kernel/kernel.asm	/^global	copr_error$/;"	l
global	kernel/kernel.asm	/^global	copr_not_available$/;"	l
global	kernel/kernel.asm	/^global	copr_seg_overrun$/;"	l
global	kernel/kernel.asm	/^global	divide_error$/;"	l
global	kernel/kernel.asm	/^global	double_fault$/;"	l
global	kernel/kernel.asm	/^global	general_protection$/;"	l
global	kernel/kernel.asm	/^global	hwint00$/;"	l
global	kernel/kernel.asm	/^global	hwint01$/;"	l
global	kernel/kernel.asm	/^global	hwint02$/;"	l
global	kernel/kernel.asm	/^global	hwint03$/;"	l
global	kernel/kernel.asm	/^global	hwint04$/;"	l
global	kernel/kernel.asm	/^global	hwint05$/;"	l
global	kernel/kernel.asm	/^global	hwint06$/;"	l
global	kernel/kernel.asm	/^global	hwint07$/;"	l
global	kernel/kernel.asm	/^global	hwint08$/;"	l
global	kernel/kernel.asm	/^global	hwint09$/;"	l
global	kernel/kernel.asm	/^global	hwint10$/;"	l
global	kernel/kernel.asm	/^global	hwint11$/;"	l
global	kernel/kernel.asm	/^global	hwint12$/;"	l
global	kernel/kernel.asm	/^global	hwint13$/;"	l
global	kernel/kernel.asm	/^global	hwint14$/;"	l
global	kernel/kernel.asm	/^global	hwint15$/;"	l
global	kernel/kernel.asm	/^global	inval_opcode$/;"	l
global	kernel/kernel.asm	/^global	inval_tss$/;"	l
global	kernel/kernel.asm	/^global	nmi$/;"	l
global	kernel/kernel.asm	/^global	overflow$/;"	l
global	kernel/kernel.asm	/^global	page_fault$/;"	l
global	kernel/kernel.asm	/^global	restart$/;"	l
global	kernel/kernel.asm	/^global	segment_not_present$/;"	l
global	kernel/kernel.asm	/^global	single_step_exception$/;"	l
global	kernel/kernel.asm	/^global	stack_exception$/;"	l
global	kernel/kernel.asm	/^global	sys_call$/;"	l
global	kernel/kernel.asm	/^global _start	; 导出 _start$/;"	l
global	kernel/syscall.asm	/^global	printx$/;"	l
global	kernel/syscall.asm	/^global	sendrec$/;"	l
global	lib/klib.asm	/^global	disable_int$/;"	l
global	lib/klib.asm	/^global	disable_irq$/;"	l
global	lib/klib.asm	/^global	disp_color_str$/;"	l
global	lib/klib.asm	/^global	disp_str$/;"	l
global	lib/klib.asm	/^global	enable_int$/;"	l
global	lib/klib.asm	/^global	enable_irq$/;"	l
global	lib/klib.asm	/^global	in_byte$/;"	l
global	lib/klib.asm	/^global	out_byte$/;"	l
global	lib/klib.asm	/^global  port_read$/;"	l
global	lib/klib.asm	/^global  port_write$/;"	l
global	lib/string.asm	/^global	memcpy$/;"	l
global	lib/string.asm	/^global	memset$/;"	l
global	lib/string.asm	/^global	strcpy$/;"	l
global	lib/string.asm	/^global	strlen$/;"	l
gs	include/proc.h	/^	t_32	gs;		\/* ┓						│			*\/$/;"	m	struct:s_stackframe
gs	include/protect.h	/^	t_32	gs;$/;"	m	struct:s_tss
has_int_msg	include/proc.h	/^	int				has_int_msg;$/;"	m	struct:proc
hd_close	driver/hd.c	/^static hd_close(int device_nr)$/;"	f	file:
hd_cmd	include/hd.h	/^struct hd_cmd {$/;"	s
hd_cmd_out	driver/hd.c	/^ void hd_cmd_out(struct hd_cmd *cmd)$/;"	f
hd_handler	driver/hd.c	/^void hd_handler(int irq)$/;"	f
hd_identify	driver/hd.c	/^void hd_identify(int drive_no)$/;"	f
hd_info	include/hd.h	/^struct hd_info$/;"	s
hd_ioctl	driver/hd.c	/^static void hd_ioctl(MESSAGE *msgp)$/;"	f	file:
hd_open	driver/hd.c	/^void hd_open(int device)$/;"	f
hd_rw	driver/hd.c	/^static void hd_rw( MESSAGE *msgp)$/;"	f	file:
hd_status	driver/hd.c	/^ t_8 hd_status;$/;"	v
hdbuf	driver/hd.c	/^ t_8 hdbuf[2*SECTOR_SIZE];$/;"	v
hds_info	driver/hd.c	/^ static struct hd_info hds_info[1];$/;"	v	typeref:struct:hd_info	file:
head	include/tty.h	/^	t_32	*head;$/;"	m	struct:tty
hwint00	kernel/kernel.asm	/^hwint00:		; Interrupt routine for irq 0 (the clock).$/;"	l
hwint01	kernel/kernel.asm	/^hwint01:		; Interrupt routine for irq 1 (keyboard)$/;"	l
hwint02	kernel/kernel.asm	/^hwint02:		; Interrupt routine for irq 2 (cascade!)$/;"	l
hwint03	kernel/kernel.asm	/^hwint03:		; Interrupt routine for irq 3 (second serial)$/;"	l
hwint04	kernel/kernel.asm	/^hwint04:		; Interrupt routine for irq 4 (first serial)$/;"	l
hwint05	kernel/kernel.asm	/^hwint05:		; Interrupt routine for irq 5 (XT winchester)$/;"	l
hwint06	kernel/kernel.asm	/^hwint06:		; Interrupt routine for irq 6 (floppy)$/;"	l
hwint07	kernel/kernel.asm	/^hwint07:		; Interrupt routine for irq 7 (printer)$/;"	l
hwint08	kernel/kernel.asm	/^hwint08:		; Interrupt routine for irq 8 (realtime clock).$/;"	l
hwint09	kernel/kernel.asm	/^hwint09:		; Interrupt routine for irq 9 (irq 2 redirected)$/;"	l
hwint10	kernel/kernel.asm	/^hwint10:		; Interrupt routine for irq 10$/;"	l
hwint11	kernel/kernel.asm	/^hwint11:		; Interrupt routine for irq 11$/;"	l
hwint12	kernel/kernel.asm	/^hwint12:		; Interrupt routine for irq 12$/;"	l
hwint13	kernel/kernel.asm	/^hwint13:		; Interrupt routine for irq 13 (FPU exception)$/;"	l
hwint14	kernel/kernel.asm	/^hwint14:		; Interrupt routine for irq 14 (AT winchester)$/;"	l
hwint15	kernel/kernel.asm	/^hwint15:		; Interrupt routine for irq 15$/;"	l
i2a	lib/stdio.c	/^PRIVATE char* i2a(int val, int base, char ** ps)$/;"	f
i_cnt	include/fs.h	/^	int i_cnt;$/;"	m	struct:inode
i_dev	include/fs.h	/^	int i_dev;$/;"	m	struct:inode
i_mode	include/fs.h	/^	t_32 i_mode;$/;"	m	struct:inode
i_nr_sects	include/fs.h	/^	t_32 i_nr_sects;$/;"	m	struct:inode
i_num	include/fs.h	/^	int i_num;$/;"	m	struct:inode
i_size	include/fs.h	/^	t_32 i_size;$/;"	m	struct:inode
i_start_sect	include/fs.h	/^	t_32 i_start_sect;$/;"	m	struct:inode
idt	include/global.h	/^EXTERN	GATE		idt[IDT_SIZE];$/;"	v
idt_ptr	include/global.h	/^EXTERN	t_8		idt_ptr[6];	\/\/ 0~15:Limit  16~47:Base$/;"	v
in_byte	lib/klib.asm	/^in_byte:$/;"	l
in_process	kernel/tty.c	/^PUBLIC void in_process(TTY * tty_p,t_32 key)$/;"	f
inc	boot/boot.asm	/^	inc	di$/;"	d
inc	boot/loader.asm	/^	inc	di$/;"	d
inform_int	kernel/proc.c	/^PUBLIC void inform_int(int task_nr)$/;"	f
init_8259A	kernel/i8259.c	/^PUBLIC void init_8259A()$/;"	f
init_clock	kernel/clock.c	/^PUBLIC void init_clock()$/;"	f
init_console	kernel/console.c	/^void init_console(CONSOLE *console_p)$/;"	f
init_descriptor	kernel/protect.c	/^PRIVATE void init_descriptor(DESCRIPTOR * p_desc, t_32 base, t_32 limit, t_16 attribute)$/;"	f
init_fs	fs/main.c	/^void init_fs()$/;"	f
init_hd	driver/hd.c	/^void init_hd()$/;"	f
init_idt_desc	kernel/protect.c	/^PUBLIC void init_idt_desc(unsigned char vector, t_8 desc_type, t_pf_int_handler handler, unsigned char privilege)$/;"	f
init_keyboard	kernel/keyboard.c	/^PUBLIC void init_keyboard()$/;"	f
init_prot	kernel/protect.c	/^PUBLIC void init_prot()$/;"	f
init_tty	kernel/tty.c	/^void init_tty(TTY *tty_p)$/;"	f
initial_eip	include/proc.h	/^	t_pf_task	initial_eip;$/;"	m	struct:s_task
inode	include/fs.h	/^struct inode{$/;"	s
inode_isize_off	include/fs.h	/^	t_32 inode_isize_off;$/;"	m	struct:super_block
inode_nr	include/fs.h	/^	int inode_nr;$/;"	m	struct:dir_entry
inode_size	include/fs.h	/^	t_32 inode_size;$/;"	m	struct:super_block
inode_start_off	include/fs.h	/^	t_32 inode_start_off;$/;"	m	struct:super_block
inode_table	fs/main.c	/^struct inode        inode_table[NR_INODE];                                                                                               $/;"	v	typeref:struct:inode
interrupt_wait	driver/hd.c	/^ void interrupt_wait()$/;"	f
inval_opcode	kernel/kernel.asm	/^inval_opcode:$/;"	l
inval_tss	kernel/kernel.asm	/^inval_tss:$/;"	l
iobase	include/protect.h	/^	t_16	iobase;	\/* I\/O位图基址大于或等于TSS段界限，就表示没有I\/O许可位图 *\/$/;"	m	struct:s_tss
irq_table	kernel/global.c	/^PUBLIC	t_pf_irq_handler	irq_table[NR_IRQ];$/;"	v
is_special	include/fs.h	87;"	d
itoa	lib/klib.c	/^char * itoa(char * str, int num)\/* 数字前面的 0 不被显示出来, 比如 0000B800 被显示成 B800 *\/$/;"	f
k_reenter	include/global.h	/^EXTERN	t_32		k_reenter;$/;"	v
kb_ack	kernel/keyboard.c	/^static void kb_ack()$/;"	f	file:
kb_in	kernel/keyboard.c	/^KB_INPUT	kb_in;$/;"	v
kb_wait	kernel/keyboard.c	/^static void kb_wait()$/;"	f	file:
kernel_esp	include/proc.h	/^	t_32	kernel_esp;	\/* <- 'popad' will ignore it			│			*\/$/;"	m	struct:s_stackframe
keyboard_handler	kernel/keyboard.c	/^PUBLIC void keyboard_handler(int irq)$/;"	f
keyboard_read	kernel/keyboard.c	/^void keyboard_read(TTY * tty_p)$/;"	f
keymap	include/keymap.h	/^t_32 keymap[NR_SCAN_CODES * MAP_COLS] = {$/;"	v
lba_high	include/hd.h	/^	t_8	lba_high;$/;"	m	struct:hd_cmd
lba_low	include/hd.h	/^	t_8	lba_low;$/;"	m	struct:hd_cmd
lba_mid	include/hd.h	/^	t_8	lba_mid;$/;"	m	struct:hd_cmd
ldt	include/protect.h	/^	t_32	ldt;$/;"	m	struct:s_tss
ldt_reg_linear	kernel/proc.c	/^int ldt_reg_linear(struct proc *p,int index)$/;"	f
ldt_sel	include/proc.h	/^	t_16				ldt_sel;		\/* selector in gdt giving ldt base and limit*\/$/;"	m	struct:proc
ldts	include/proc.h	/^	DESCRIPTOR			ldts[LDT_SIZE];		\/* local descriptors for code and data *\/$/;"	m	struct:proc
limit_high_attr2	include/protect.h	/^	t_8	limit_high_attr2;	\/* G(1) D(1) 0(1) AVL(1) LimitHigh(4) *\/$/;"	m	struct:descriptor
limit_low	include/protect.h	/^	t_16	limit_low;		\/* Limit *\/$/;"	m	struct:descriptor
logical	include/hd.h	/^	struct part_info	logical[NR_SUB_PER_DRIVE];$/;"	m	struct:hd_info	typeref:struct:hd_info::part_info
m1	include/msg.h	/^		struct mess1 m1;$/;"	m	union:mess::__anon1	typeref:struct:mess::__anon1::mess1
m1i1	include/msg.h	/^	int m1i1;$/;"	m	struct:mess1
m1i2	include/msg.h	/^	int m1i2;$/;"	m	struct:mess1
m1i3	include/msg.h	/^	int m1i3;$/;"	m	struct:mess1
m1i4	include/msg.h	/^	int m1i4;$/;"	m	struct:mess1
m2	include/msg.h	/^		struct mess2 m2;$/;"	m	union:mess::__anon1	typeref:struct:mess::__anon1::mess2
m2p1	include/msg.h	/^	void *m2p1;$/;"	m	struct:mess2
m2p2	include/msg.h	/^	void *m2p2;$/;"	m	struct:mess2
m2p3	include/msg.h	/^	void *m2p3;$/;"	m	struct:mess2
m2p4	include/msg.h	/^	void *m2p4;$/;"	m	struct:mess2
m3	include/msg.h	/^		struct mess3 m3;$/;"	m	union:mess::__anon1	typeref:struct:mess::__anon1::mess3
m3i1	include/msg.h	/^	int m3i1;$/;"	m	struct:mess3
m3i2	include/msg.h	/^	int m3i2;$/;"	m	struct:mess3
m3i3	include/msg.h	/^	int m3i3;$/;"	m	struct:mess3
m3i4	include/msg.h	/^	int m3i4;$/;"	m	struct:mess3
m3l1	include/msg.h	/^	t_64	m3l1;$/;"	m	struct:mess3
m3l2	include/msg.h	/^	t_64	m3l2;$/;"	m	struct:mess3
m3p1	include/msg.h	/^	void *m3p1;$/;"	m	struct:mess3
m3p2	include/msg.h	/^	void *m3p2;$/;"	m	struct:mess3
magic	include/fs.h	/^	t_32	magic;$/;"	m	struct:super_block
max	include/math.h	4;"	d
memcmp	lib/memstring.c	/^int memcmp(const void * s1, const void *s2, int n)$/;"	f
memcpy	lib/string.asm	/^memcpy:$/;"	l
memset	lib/string.asm	/^memset:$/;"	l
mess	include/msg.h	/^typedef struct mess{$/;"	s
mess1	include/msg.h	/^struct mess1{$/;"	s
mess2	include/msg.h	/^struct mess2{$/;"	s
mess3	include/msg.h	/^struct mess3{$/;"	s
milli_delay	kernel/clock.c	/^PUBLIC void milli_delay(int milli_sec)$/;"	f
min	include/math.h	5;"	d
mkfs	fs/main.c	/^static void mkfs()$/;"	f	file:
msg_receive	kernel/proc.c	/^static int msg_receive(struct proc * current_pro,int src, MESSAGE *m)$/;"	f	file:
msg_send	kernel/proc.c	/^static int msg_send(struct proc *current, int dest, MESSAGE *m)$/;"	f	file:
msgtype	include/msg.h	/^enum msgtype{$/;"	g
mul	boot/boot.asm	/^	mul	dh$/;"	d
mul	boot/loader.asm	/^	mul	dh$/;"	d
myroot_inode	fs/main.c	/^struct inode *      myroot_inode;$/;"	v	typeref:struct:inode
n_1st_sect	include/fs.h	/^	t_32 n_1st_sect;$/;"	m	struct:super_block
name	include/fs.h	/^	char name[MAX_FILENAME_LEN];$/;"	m	struct:dir_entry
name	include/proc.h	/^	char				name[16];		\/* name of the process *\/$/;"	m	struct:proc
name	include/proc.h	/^	char		name[32];$/;"	m	struct:s_task
new_dir_entry	fs/opera.c	/^static void new_dir_entry(struct inode *dir_inode, int inode_nr, char *filename)$/;"	f	file:
new_inode	fs/opera.c	/^static struct inode* new_inode(int dev, int inode_nr, int start_sect)$/;"	f	file:
next_sending	include/proc.h	/^	struct 	proc	*next_sending;$/;"	m	struct:proc	typeref:struct:proc::proc
nmi	kernel/kernel.asm	/^nmi:$/;"	l
nr_imap_sects	include/fs.h	/^	t_32 nr_imap_sects;$/;"	m	struct:super_block
nr_inode_sects	include/fs.h	/^	t_32 nr_inode_sects;$/;"	m	struct:super_block
nr_inodes	include/fs.h	/^	t_32	nr_inodes;$/;"	m	struct:super_block
nr_sects	include/fs.h	/^	t_32 nr_sects;$/;"	m	struct:super_block
nr_sects	include/hd.h	/^	t_32 nr_sects;		\/**$/;"	m	struct:part_entry
nr_smap_sects	include/fs.h	/^	t_32 nr_smap_sects;$/;"	m	struct:super_block
nr_tty	include/proc.h	/^	int 			nr_tty;$/;"	m	struct:proc
num_lock	kernel/keyboard.c	/^PRIVATE int num_lock;$/;"	v
num_lock	kernel/keyboard.c	/^static int num_lock;$/;"	v	file:
offset_high	include/protect.h	/^	t_16	offset_high;	\/* Offset High *\/$/;"	m	struct:s_gate
offset_low	include/protect.h	/^	t_16	offset_low;	\/* Offset Low *\/$/;"	m	struct:s_gate
open	lib/unistd.c	/^int open(const char *pathname, int flags)$/;"	f
open_cnt	include/hd.h	/^	int			open_cnt;$/;"	m	struct:hd_info
org	boot/loader.asm	/^org  0100h$/;"	l
out_byte	lib/klib.asm	/^out_byte:$/;"	l
out_char	kernel/console.c	/^void out_char(CONSOLE * p_con,char ch)$/;"	f
overflow	kernel/kernel.asm	/^overflow:$/;"	l
p_flags	include/proc.h	/^	int 			p_flags;$/;"	m	struct:proc
p_head	include/keyboard.h	/^	char * p_head;$/;"	m	struct:s_kb
p_msg	include/proc.h	/^	MESSAGE			*p_msg;$/;"	m	struct:proc
p_proc_ready	include/global.h	/^EXTERN	struct proc *p_proc_ready;$/;"	v	typeref:struct:proc
p_recvfrom	include/proc.h	/^	int				p_recvfrom;$/;"	m	struct:proc
p_sendto	include/proc.h	/^	int 			p_sendto;$/;"	m	struct:proc
p_tail	include/keyboard.h	/^	char * p_tail;$/;"	m	struct:s_kb
page_fault	kernel/kernel.asm	/^page_fault:$/;"	l
page_switch	kernel/tty.c	/^PRIVATE void page_switch()$/;"	f
panic	lib/err.c	/^void panic(const char *fmt, ...)$/;"	f
part_entry	include/hd.h	/^struct part_entry {$/;"	s
part_info	include/hd.h	/^struct part_info {$/;"	s
partition	driver/hd.c	/^static void partition(int device, int style)$/;"	f	file:
pcaller	fs/main.c	/^struct proc * pcaller=0;$/;"	v	typeref:struct:proc
phys_copy	include/string.h	19;"	d
phys_set	include/string.h	20;"	d
pid	include/proc.h	/^	t_32				pid;			\/* process id passed in from MM *\/$/;"	m	struct:proc
pop	boot/boot.asm	/^	pop	dx$/;"	d
pop	boot/loader.asm	/^	pop	dx$/;"	d
pop	kernel/kernel.asm	/^	pop	ds$/;"	d
port_read	lib/klib.asm	/^port_read:$/;"	l
port_write	lib/klib.asm	/^port_write:$/;"	l
primary	include/hd.h	/^	struct part_info	primary[NR_PRIM_PER_DRIVE];$/;"	m	struct:hd_info	typeref:struct:hd_info::part_info
print_hdsinfo	driver/hd.c	/^static void print_hdsinfo(struct hd_info *hdi)$/;"	f	file:
print_identify_info	driver/hd.c	/^void print_identify_info(t_16 *hd_info)$/;"	f
printf	lib/stdio.c	/^int printf(const char *fmt,...)$/;"	f
printl	include/nostdio.h	4;"	d
printx	kernel/syscall.asm	/^printx:$/;"	l
priority	include/proc.h	/^	int				priority;$/;"	m	struct:proc
proc	include/proc.h	/^typedef struct proc{$/;"	s
proc2pid	include/proc.h	66;"	d
proc_table	kernel/global.c	/^PUBLIC	PROCESS	proc_table[NR_PROCS];$/;"	v
push	boot/boot.asm	/^	push	dx$/;"	d
push	boot/loader.asm	/^	push	dx$/;"	d
push	kernel/kernel.asm	/^	push	ds	; ┃$/;"	d
put_inode	fs/misc.c	/^void put_inode(struct inode * pinode)$/;"	f
put_irq_handler	kernel/i8259.c	/^PUBLIC void put_irq_handler(int irq, t_pf_irq_handler handler)$/;"	f
put_key2tty	kernel/tty.c	/^void put_key2tty(TTY *tty_p, t_32 key)$/;"	f
q_sending	include/proc.h	/^	struct	proc	*q_sending;$/;"	m	struct:proc	typeref:struct:proc::proc
read	lib/unistd.c	/^int read(int fd, void *buf, int count)$/;"	f
read_super_block	fs/main.c	/^static void read_super_block(int dev)$/;"	f	file:
regs	include/proc.h	/^	STACK_FRAME			regs;			\/* process' registers saved in stack frame *\/$/;"	m	struct:proc
reset_msg	kernel/proc.c	/^void reset_msg(MESSAGE *p)$/;"	f
restart	kernel/kernel.asm	/^restart:$/;"	l
restart_reenter	kernel/kernel.asm	/^restart_reenter:$/;"	l
retaddr	include/proc.h	/^	t_32	retaddr;	\/* return address for assembly code save()	│			*\/$/;"	m	struct:s_stackframe
root_inode	include/fs.h	/^	t_32 root_inode;$/;"	m	struct:super_block
rw_sector	fs/main.c	/^void rw_sector( int device, t_64 pos, int proc_nr,  void *buf, int bytes, int io_type)$/;"	f
s_console	include/console.h	/^typedef struct s_console{$/;"	s
s_gate	include/protect.h	/^typedef struct s_gate$/;"	s
s_kb	include/keyboard.h	/^typedef struct s_kb{$/;"	s
s_stackframe	include/proc.h	/^typedef struct s_stackframe {	\/* proc_ptr points here				↑ Low			*\/$/;"	s
s_task	include/proc.h	/^typedef struct s_task {$/;"	s
s_tss	include/protect.h	/^typedef struct s_tss {$/;"	s
save	kernel/kernel.asm	/^save:$/;"	l
sb_dev	include/fs.h	/^	int sb_dev;$/;"	m	struct:super_block
schedule	kernel/proc.c	/^PUBLIC void schedule()$/;"	f
scroll_lock	kernel/keyboard.c	/^PRIVATE int scroll_lock;$/;"	v
scroll_lock	kernel/keyboard.c	/^static int scroll_lock;$/;"	v	file:
scroll_screen	kernel/console.c	/^void scroll_screen(CONSOLE *console_p, int direction)$/;"	f
search_file	fs/misc.c	/^int search_file(char *path)$/;"	f
sector_count	include/hd.h	/^	t_8	sector_count;$/;"	m	struct:hd_cmd
seg2phys	kernel/protect.c	/^PUBLIC t_32 seg2phys(t_16 seg)$/;"	f
segment_not_present	kernel/kernel.asm	/^segment_not_present:$/;"	l
selector	include/protect.h	/^	t_16	selector;	\/* Selector *\/$/;"	m	struct:s_gate
send_recv	kernel/proc.c	/^int send_recv(int function, int src_dest, MESSAGE *msg)$/;"	f
sendrec	kernel/syscall.asm	/^sendrec:$/;"	l
set_console_start_addr	kernel/console.c	/^void set_console_start_addr(t_32 addr)$/;"	f
set_cursor	kernel/console.c	/^void set_cursor(t_32 addr)$/;"	f
set_cursor_length	kernel/console.c	/^void set_cursor_length()$/;"	f
set_cursor_location	kernel/console.c	/^void set_cursor_location(t_32 addr)$/;"	f
set_leds	kernel/keyboard.c	/^static void set_leds()$/;"	f	file:
shift_l	kernel/keyboard.c	/^PRIVATE int shift_l;$/;"	v
shift_r	kernel/keyboard.c	/^PRIVATE int shift_r;$/;"	v
single_step_exception	kernel/kernel.asm	/^single_step_exception:$/;"	l
size	include/hd.h	/^	t_32	size;	\/* how many sectors in this partition (NOT byte size, but SECTOR number) *\/$/;"	m	struct:part_info
source	include/msg.h	/^	int source;$/;"	m	struct:mess
spin	lib/err.c	/^void spin(char *funcname)$/;"	f
sprintf	lib/stdio.c	/^int sprintf(char *buf, const char *fmt, ...)$/;"	f
spurious_irq	kernel/i8259.c	/^PUBLIC void spurious_irq(int irq)$/;"	f
ss	include/proc.h	/^	t_32	ss;		\/*  ┛						┷High			*\/$/;"	m	struct:s_stackframe
ss	include/protect.h	/^	t_32	ss;$/;"	m	struct:s_tss
ss0	include/protect.h	/^	t_32	ss0;		\/*   "   segment  "  "    "        "     *\/$/;"	m	struct:s_tss
ss1	include/protect.h	/^	t_32	ss1;$/;"	m	struct:s_tss
ss2	include/protect.h	/^	t_32	ss2;$/;"	m	struct:s_tss
stack_exception	kernel/kernel.asm	/^stack_exception:$/;"	l
stacksize	include/proc.h	/^	int		stacksize;$/;"	m	struct:s_task
start_cyl	include/hd.h	/^	t_8 start_cyl;		\/**$/;"	m	struct:part_entry
start_head	include/hd.h	/^	t_8 start_head;		\/**$/;"	m	struct:part_entry
start_sect	include/hd.h	/^	t_32 start_sect;	\/**$/;"	m	struct:part_entry
start_sector	include/hd.h	/^	t_8 start_sector;	\/**$/;"	m	struct:part_entry
strcat	lib/memstring.c	/^char * strcat(char * s1, const char *s2)$/;"	f
strcmp	lib/memstring.c	/^int strcmp(const char * s1, const char *s2)$/;"	f
strcpy	lib/string.asm	/^strcpy:$/;"	l
strip_path	fs/misc.c	/^int strip_path(char *filename, const char *pathname, struct inode **ppinode)$/;"	f
strlen	lib/string.asm	/^strlen:   $/;"	l
super_block	fs/main.c	/^struct super_block  super_block[NR_SUPER_BLOCK];$/;"	v	typeref:struct:super_block
super_block	include/fs.h	/^struct super_block{$/;"	s
switch_console	kernel/console.c	/^void switch_console(CONSOLE *console_p)$/;"	f
syn_cursor	kernel/tty.c	/^PUBLIC void syn_cursor()$/;"	f
sync_inode	fs/misc.c	/^void sync_inode(struct inode *p)$/;"	f
sys_call	kernel/kernel.asm	/^sys_call:$/;"	l
sys_call_table	kernel/global.c	/^PUBLIC	t_sys_call		sys_call_table[NR_SYS_CALL] = {sys_printx,sys_sendrec};$/;"	v
sys_id	include/hd.h	/^	t_8 sys_id;		\/**$/;"	m	struct:part_entry
sys_printx	kernel/tty.c	/^int sys_printx(int _unused1, int _unused2, char * s, struct proc *proc_p)$/;"	f
sys_sendrec	kernel/proc.c	/^int sys_sendrec(int function, int src_dest, MESSAGE *m, struct proc *p)$/;"	f
szMemChkTitle	boot/loader.asm	/^szMemChkTitle		equ	BaseOfLoaderPhyAddr + _szMemChkTitle$/;"	d
szRAMSize	boot/loader.asm	/^szRAMSize		equ	BaseOfLoaderPhyAddr + _szRAMSize$/;"	d
szReturn	boot/loader.asm	/^szReturn		equ	BaseOfLoaderPhyAddr + _szReturn$/;"	d
t_16	include/type.h	/^typedef	unsigned short		t_16;$/;"	t
t_32	include/type.h	/^typedef	unsigned int		t_32;$/;"	t
t_64	include/type.h	/^typedef	unsigned long long	t_64;$/;"	t
t_8	include/type.h	/^typedef	unsigned char		t_8;$/;"	t
t_bool	include/type.h	/^typedef	int			t_bool;$/;"	t
t_pf_int_handler	include/type.h	/^typedef	void	(*t_pf_int_handler)	();$/;"	t
t_pf_irq_handler	include/type.h	/^typedef	void	(*t_pf_irq_handler)	(int irq);$/;"	t
t_pf_task	include/type.h	/^typedef	void	(*t_pf_task)		();$/;"	t
t_port	include/type.h	/^typedef	unsigned int		t_port;$/;"	t
t_sys_call	include/type.h	/^typedef	void*	t_sys_call;$/;"	t
tail	include/tty.h	/^	t_32	*tail;$/;"	m	struct:tty
task_fs	fs/main.c	/^void task_fs()$/;"	f
task_hd	driver/hd.c	/^void task_hd()$/;"	f
task_stack	kernel/global.c	/^PUBLIC	char	task_stack[STACK_SIZE_TOTAL];$/;"	v
task_sys	kernel/systask.c	/^void task_sys()$/;"	f
task_table	kernel/global.c	/^PUBLIC	TASK	task_table[NR_TASKS] = {{task_tty, STACK_SIZE_TTY, "tty"},$/;"	v
task_tty	kernel/tty.c	/^PUBLIC void task_tty()$/;"	f
ticks	include/global.h	/^EXTERN	int		ticks;$/;"	v
ticks	include/proc.h	/^	int				ticks;			\/* remained ticks *\/$/;"	m	struct:proc
times	boot/boot.asm	/^times 	510-($-$$)	db	0	; 填充剩下的空间，使生成的二进制代码恰好为512字节$/;"	l
tinix_main	kernel/main.c	/^PUBLIC int tinix_main()$/;"	f
trap	include/protect.h	/^	t_16	trap;$/;"	m	struct:s_tss
tss	include/global.h	/^EXTERN	TSS		tss;$/;"	v
tty	include/tty.h	/^typedef	struct tty{$/;"	s
tty_read	kernel/tty.c	/^void tty_read(TTY *tty_p)$/;"	f
tty_table	kernel/global.c	/^TTY	tty_table[NR_TTY];$/;"	v
tty_write	kernel/tty.c	/^void tty_write(TTY *tty_p)$/;"	f
type	include/msg.h	/^	int type;$/;"	m	struct:mess
u	include/msg.h	/^	}u;$/;"	m	struct:mess	typeref:union:mess::__anon1
unblock	kernel/proc.c	/^void unblock(struct proc *p)$/;"	f
user_proc_table	kernel/global.c	/^PUBLIC	TASK	user_proc_table[NR_USER_PROCS] = {$/;"	v
va2la	kernel/proc.c	/^void * va2la(int pid, void * va)$/;"	f
va_list	include/type.h	/^typedef char* 	va_list;$/;"	t
vir2phys	include/protect.h	153;"	d
vmem_limit	include/console.h	/^	unsigned int vmem_limit;$/;"	m	struct:s_console
vsprintf	lib/stdio.c	/^PUBLIC int vsprintf(char *buf, const char *fmt, va_list args)$/;"	f
wRootDirSizeForLoop	boot/boot.asm	/^wRootDirSizeForLoop	dw	RootDirSectors	; Root Directory 占用的扇区数, 在循环中会递减至零.$/;"	d
wRootDirSizeForLoop	boot/loader.asm	/^wRootDirSizeForLoop	dw	RootDirSectors	; Root Directory 占用的扇区数$/;"	d
wSectorNo	boot/boot.asm	/^wSectorNo		dw	0		; 要读取的扇区号$/;"	d
wSectorNo	boot/loader.asm	/^wSectorNo		dw	0		; 要读取的扇区号$/;"	d
waitfor	driver/hd.c	/^ int waitfor(int mask, int val, int timeout)$/;"	f
write	lib/unistd.c	/^int write(int fd, const void *buf, int count)$/;"	f
write_tty	kernel/tty.c	/^void write_tty(TTY * tty_p,char *buf,int len)$/;"	f
